Лабораторна робота 2. Поглиблені можливості розробки об'єктно-орієнтованих програм.

Завдання: реалізувати програму обліку прийому тварин для ветеринарної клініки.
Функціонал: Додаток повинен мати консольний інтерфейс та надавати можливості:
    1. Додавання нової тварини – необхідно надавати вибір типу тварини. Як тільки вибір зроблено - користувач починає
       вводити інформацію про візит: кличка тварини, ІПН та ПІБ господаря, діагноз, вага, лікування, дата останнього
       візиту (може бути null якщо клієнт звернувся вперше) та опис первинного огляду, яке вноситься як опитування
       станів специфічних для типу тваринних частин тіла (наприклад, якщо це пташка – то програма запитує у користувача
       стан пір'я та дзьоба, якщо рибка – плавників, якщо кішка – то стан лап та хвоста тощо).
       Вимоги до виконання: типи тварин слід реалізувати як enum. Описати базовий клас “Тварини”, у яких прописати
       загальні всім тварин характеристики. Далі реалізувати класи конкретних тварин, успадковані від класу “Тварина”
       і які мають унікальні характеристики (такі як дзьоб, пір'я, плавники тощо).
    2. Пошук тварини по ІПН господаря - у програму вводиться ІПН клієнта, у відповідь програма друкує всі дані про
       тварину та її діагноз.
       Вимоги до виконання: програма повинна реалізовувати друк класів за допомогою перевизначення методу toString().
    3. Розрахунок вартості прийому - програма повинна мати можливість вважати ІПН господаря, знайти по ньому тварину
       та отримати вартість прийому за типом тварини. Вартість прийому розраховується як - константне значення,
       унікальне для кожної конкретної тварини (вартість прийому рибки не повинна дорівнювати вартості прийому жирафу)
       помножене на вагу тварини. Після отримання ціни - система друкує "Чек" в консоль програми, що містить такі дані:
           ІПН,
           Назва клініки,
           Сума до оплати,
           Пророцтво на сьогодні (випадково вибирається один з 5 заздалегідь заданих варіантів).
       Вимоги до виконання: Потрібно продати інтерфейс, в якому описати спосіб отримання ціни. Всі події з ціною вести
       через змінну з типом створеного інтерфейсу.

Опис роботи:
Крім окремих примітивних типів даних і класів Java є такий тип як enum або перерахування. Перерахування представляють
набір логічно пов'язаних констант. Оголошення перерахування відбувається за допомогою оператора enum, після якого йде
назва перерахування. Потім йде список елементів перерахування через кому:
    public enum SomeEnum {
        TYPE0, TYPE1, TYPE2
    }

Оскільки перерахування - це тип даних, його можна використовувати як клас, задаючи конструктори та методи:
    public enum SomeEnum {
        TYPE0("a"), TYPE1("b"), TYPE2("c");
        private String someData;
        SomeEnum(String someData) {
            this.someData = someData;
        }
        public String getSomeData() {
            return someData;
        }
    }

Створювати нові об'єкти через оператор new не можна, але створювати змінні даного типу та працювати з ними цілком
допустимо:
    public class MainApp {
        public static void main(String[] args) {
            SomeEnum someEnum = SomeEnum.TYPE0;
            String someData = SomeEnum.TYPE0.getSomeData(); // Присвоєно "a"
        }
    }

крім того, при необхідності можна перевизначати описані методи, за допомогою чого до кожної константи можна прив'язувати
набір відповідних тільки для неї реалізацій методів:
    public enum SomeEnum {
        TYPE0("a"),
        TYPE1("b") {
            public int action(int x, int y) {
                return x + y;
            }
        },
        TYPE2("c");
        private String someData;
        public int action(int x, int y) {
            return 0;
        }
        SomeEnum(String someData) {
            this.someData = someData;
        }
        public String getSomeData() {
            return someData;
        }
    }

приклад роботи з таким enum виглядає таким чином:
    public class MainApp {
        public static void main(String[] args) {
            System.out.println(SomeEnum.TYPE1.action(2, 3)); // Виведе 5
            System.out.println(SomeEnum.TYPE0.action(2, 3)); // Виведе 0, оскільки метод не перевизначено
        }
    }

Необхідність наявності та використання enum-ів обумовлена безпекою та чистотою Вашого коду - альтернативою перерахувань
можуть бути константи, але вони будуть позбавлені описаного функціонала та захисту від додавання нових значень у процесі
роботи з ними.

Тепер, перейдемо до ще одного аспекту поліморфності мови Java та потужного інструменту розробки об'єктно-орієнтованих
додатків – інтерфейсів. Ключове слово interface використовується для створення абстрактних класів. Творець інтерфейсу
визначає імена методів, списки аргументів і типи значень, що повертаються, але не тіла методів.

Наявність слова interface означає, що саме так мають виглядати всі класи, які реалізують цей інтерфейс. Таким чином,
будь-який код, що використовує конкретний інтерфейс, знає тільки те, які методи викликаються для цього інтерфейсу, але
не більше.

Щоб створити інтерфейс, використовуйте ключове слово interface замість class. Як і у випадку з класами, ви можете додати
перед словом interface специфікатор доступу public (але якщо інтерфейс визначений у файлі, що має те саме ім'я) або
залишити для нього дружній доступ, якщо він буде використовуватися тільки в межах свого пакета. Інтерфейс може містити
поля, але вони автоматично статичні (static) і незмінні (final). Усі методи та змінні неявно оголошуються як public.

Клас, який має намір використовувати певний інтерфейс, використовує ключове слово implements. Воно вказує, що інтерфейс
лише визначає форму, яку потрібно наповнити кодом. Методи, що реалізують інтерфейс, мають бути оголошені як public.

Інтерфейсів у класу може бути кілька, тоді вони перераховуються за ключовим словом implements і поділяються комами.

Розглянемо приклад: необхідно виводити на екран JSON та XML рядок, описані у відповідних класах. Раніше нам довелося б
створювати два окремі методи виведення - для об'єкта, що містить JSON і для об'єкта, що містить XML. Однак, використання
інтерфейсів допоможе нам вирішити цю проблему. Для початку створимо наш інтерфейс Data, який містить єдиний метод
отримання даних:
    public interface Data {
        String getData();
    }

Далі створимо два класи, що зберігають XML і JSON та імплементують цей інтерфейс:
Клас для XML:
    public class XMLData implements Data {
        private String XML =
            "<tests>" +
                "someXML1" +
            "</tests>" +
            "<tests>" +
                "someXML2" +
            "</tests>";
        public String getData() {
            return XML;
        }
    }

Клас для JSON:
    public class JsonData implements Data {
        private String json =
            "{" +
                "\"head\" : \"HEAD\", " +
                "\"body\" : \"HEAD\"" +
            "}";
        public String getData() {
            return json;
        }
    }

Зверніть увагу, що метод getData() має бути реалізований, оскільки ми прописали його в нашому інтерфейсі, проте
реалізації можуть бути зовсім різні - так, у нашому прикладі метод повертає зовсім різні рядки, унікальні для кожного
з класів.

Давайте уявимо, що ми не маємо інтерфейсу, і спробуємо виконати наше завдання з написання методу друку рядків “старим”
шляхом:
    public class MainApp {
        private static void printData(XMLData data) {
            System.out.println(data.getData());
        }
        private static void printData(JsonData data) {
            System.out.println(data.getData());
        }
        public static void main(String[] args) {
            printData(new JsonData());
            printData(new XMLData());
        }
    }

Нічого незвичайного в лістингу немає - ми просто створили кілька методів, кожен із яких приймає на вхід об'єкт
потрібного типу та працює з ним. Однак, використання інтерфейсів дозволить нам написати ОДИН загальний метод, в якому
ми можемо задати загальну логіку по роботі з нашим контрактом-інтерфейсом, і для цього досить просто змінити тип
значення, що приймається на тип інтерфейсу:
    public class MainApp {
        private static void printData(Data data) {
            System.out.println(data.getData());
        }
        public static void main(String[] args) {
            printData(new JsonData());
            printData(new XMLData());
        }
    }

Ось і все! Java розуміє, з яким контрактом вона має працювати, і приймає всі сумісні з ним об'єкти. Тепер уважно
подивіться на завдання та подумайте - де і як можна використовувати інтерфейс, скоротивши тим самим роботу для себе!
Бажаю удачі! =)
